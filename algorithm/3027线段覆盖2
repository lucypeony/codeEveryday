题目描述 Description

    数轴上有n条线段，线段的两端都是整数坐标，坐标范围在0~1000000，每条线段有一个价值，请从n条线段中挑出若干条线段，使得这些线段两两不覆盖（端点可以重合）且线段价值之和最大。

    n<=1000

输入描述 Input Description

    第一行一个整数n，表示有多少条线段。

    接下来n行每行三个整数, ai bi ci，分别代表第i条线段的左端点ai，右端点bi（保证左端点<右端点）和价值ci。

输出描述 Output Description

    输出能够获得的最大价值

样例输入 Sample Input

    3

    1 2 1

    2 3 2

    1 3 4

样例输出 Sample Output

    4

数据范围及提示 Data Size & Hint

    数据范围

    对于40%的数据，n≤10；

    对于100%的数据，n≤1000；

    0<=ai,bi<=1000000

    0<=ci<=1000000


算法：
1.先将线段排序。

  由于范围小，且DP的特点就是不耗时，我们直接用最简单的选择排序即可。

  按照右端点从小到大排序。原因是循环结构中是i从1到n, i比较小的时候尽可能选右端点比较小的，这样才可以为后面的线段留下更大的空间。

2.DP  

     f[i]表示：算前i条线段时，选上第i条线段，能获得的最大价值。

      f[i]=max{f[j]}+c[i]     ( 2<=i<=n;   1<=j<=i-1;) （if b[j]<=a[i]即j的右端点在i的左端点左边。即判断不重合）

     价值c[i]不需要使用,可以直接用read(a[i],b[i],f[i])代替，并且同时完成了初始化。式子改为f[i]=max{f[j]}+f[i]。

       (最后输出)ans=max{f[i]}     

    以上式子能够成立的原因是，从坐标较小的线段向坐标较大的线段枚举的过程中，每一次的取之都是总结了i-1个数中f的最大值。

      每一个f[x]和f[y]（x在y之前）的计算过程中关系只右两种：在能够取得f[x]的情况下（想象数轴上被前x条线段覆盖），线段y能/否 加入。

     若能加入，那么含有x的最优解一定能在最后的f[y]中有体现（通过加和关系）；

     若不能加入，那么f[y]的值跟f[x]的值没有任何联系，f[x]的值完全可以在后来与f[y]进行max比较与选择。

     综上请体会

3.输出f[i]数组中的最大值。
